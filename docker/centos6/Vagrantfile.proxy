# -*- mode: ruby -*-
# vi: set ft=ruby :

ENV['VAGRANT_DEFAULT_PROVIDER'] = 'docker'

VAGRANTFILE_API_VERSION = "2"

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|

  # within this host VM we will be running dockers 
  config.vm.provision "docker"

  # Make this VM reachable on the host network as well, so that other
  # VM's running other browsers can access our dev server.
  config.vm.network :private_network, ip: "192.168.10.200"

  # Make it so that network access from the vagrant guest is able to
  # use SSH private keys that are present on the host without copying
  # them into the VM.
  config.ssh.forward_agent = true
 
  # The following line terminates all ssh connections. Therefore
  # Vagrant will be forced to reconnect.
  config.vm.provision "shell", inline:
    "ps aux | grep 'sshd:' | awk '{print $2}' | xargs kill"
 
  config.vm.define "dockerhost"
  config.vm.box = "centos/centos6"
  config.vm.network "forwarded_port", guest: 8080, host: 8080
 
  config.vm.provider :virtualbox do |v|

      # this is a dockerhost
      vb.name = "dockerhost"

      # This setting gives the VM 1024MB of RAM instead of the default 384.
      v.customize ["modifyvm", :id, "--memory", [ENV['TRUSTRAP_VM_MEM'].to_i, 1024].max]
 
      # Who has a single core cpu these days anyways?
      cpu_count = 4

      # Determine the available cores in host system.
      if RUBY_PLATFORM =~ /linux/
        cpu_count = `nproc`.to_i
      elsif RUBY_PLATFORM =~ /darwin/
        cpu_count = `sysctl -n hw.ncpu`.to_i
      end

      # Assign additional cores to the guest OS.
      v.customize ["modifyvm", :id, "--cpus", cpu_count]
      v.customize ["modifyvm", :id, "--ioapic", "on"]

      # This setting makes it so that network access from inside the vagrant guest
      # is able to resolve DNS using the hosts VPN connection.
      v.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
  end
 
end
